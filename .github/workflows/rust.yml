# based on: 
# https://ectobit.com/blog/speed-up-github-actions-rust-pipelines/
name: Rust

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  RUSTFLAGS: -C instrument-coverage=all
  RUST_UP_DEFAULT: nightly-2023-05-01
  CARGO_TERM_COLOR: always
  # note you will find ~/.cargo/bin/ for caching but that we resolve using preperation
  CARGO_CACHE_PATH:  |
    ~/.cargo/registry/index/
    ~/.cargo/registry/cache/
    ~/.cargo/git/db/
    target/   
  RUSTUP_CACHE_PATH:  |
    ~/.rustup
    ~/.cargo/bin/   
  COMPONENT: clippy,rustfmt # NOTE: if you change COMPONENT, also increase the CACHE_VERSION!
  CACHE_VERSION: 24


jobs:
  preperation:
    runs-on: ubuntu-latest
    steps:
      # inpiration from: https://github.com/johnthagen/min-sized-rust
      - run: mkdir -p ~/.cargo
      - run: echo "[profile.min]" > ~/.cargo/config.toml
      - run: echo inherits = \"release\" >>  ~/.cargo/config.toml
      - run: echo strip = true>> ~/.cargo/config.toml
      - run: echo opt-level = \"z\" >> ~/.cargo/config.toml
      - run: echo codegen-units = 1 >> ~/.cargo/config.toml
      - run: cat ~/.cargo/config.toml
      - id: cache-rustup
        name: Cache Rust toolchain
        uses: actions/cache@v3
        with:
          path: ${{ env.RUSTUP_CACHE_PATH }}
          key: toolchain-${{ env.RUST_UP_DEFAULT }}-v${{ env.CACHE_VERSION }}-
      - if: ${{ steps.cache-rustup.outputs.cache-hit != 'true' }}
        run: |
            rustup toolchain install ${{ env.RUST_UP_DEFAULT }} --profile minimal --component ${{ env.COMPONENT }}
            rustup default ${{ env.RUST_UP_DEFAULT }}  
            cargo install cargo-build-dependencies --profile min
            cargo install grcov --profile min
      - run: ls -1lh ~/.cargo/bin/
    
          
  build:
    runs-on: ubuntu-latest
    needs: preperation
    steps:
    - id: cache-rustup
      name: Obtain Rust toolchain
      uses: actions/cache/restore@v3
      with:
          path: ${{ env.RUSTUP_CACHE_PATH }}
          key: toolchain-${{ env.RUST_UP_DEFAULT }}-v${{ env.CACHE_VERSION }}-
          fail-on-cache-miss: true # does not brake the build ?
    - if: ${{ steps.cache-rustup.outputs.cache-hit != 'true' }}
      run: echo 'Failed to retrieve cache';exit 1
    - uses: actions/checkout@v4 
    - id: cache-cargo
      name: Restore cargo cache if exists
      uses: actions/cache/restore@v3
      with:
        path: ${{ env.CARGO_CACHE_PATH }}
        key: ${{ runner.os }}-cargo-${{ env.CACHE_VERSION }}-${{ hashFiles('**/Cargo.lock') }}
    - run: export RUSTFLAGS="${{ env.RUSTFLAGS }}"
    - run: cargo build-dependencies
    - run: cargo check
    - name: Make '~/.cargo/git/db' in case git repositories are not used
      run:  mkdir -p ~/.cargo/git/db  
    - run: ls -1lh ~/.cargo/registry/index/
    - run: ls -1lh ~/.cargo/registry/cache/
    - run: ls -1lh ~/.cargo/git/db/
    - run: ls -1lh target/   
    - name: Save to cargo cache
      uses: actions/cache/save@v3
      if: always()
      with:
        path: ${{ env.CARGO_CACHE_PATH }}
        key: ${{ runner.os }}-cargo-${{ env.CACHE_VERSION }}-${{ hashFiles('**/Cargo.lock') }}
    # If the tests fail, then at least we have a cache...
    - name: cargo build
      run: cargo build
    - name: Build related test but no execution
      run: cargo test --no-run
    - name: Run tests
      run: cargo test run
            
  fmt:
    needs: [preperation]
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always
    steps:
      - id: cache-rustup
        name: Obtain Rust toolchain
        uses: actions/cache/restore@v3
        with:
          path: ${{ env.RUSTUP_CACHE_PATH }}
          key: toolchain-${{ env.RUST_UP_DEFAULT }}-v${{ env.CACHE_VERSION }}-
      - if: ${{ steps.cache-rustup.outputs.cache-hit != 'true' }}
        run: echo 'Failed to retrieve cache';exit 1
      # The actual job
      - uses: actions/checkout@v4 
      - name: Fmt
        run: cargo fmt --all -- --check

  clippy:
    needs: [build]
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always
    steps:
      - run: export RUSTFLAGS="${{ env.RUSTFLAGS }}"
      - id: cache-rustup
        name: Obtain Rust toolchain
        uses: actions/cache/restore@v3
        with:
          path: ${{ env.RUSTUP_CACHE_PATH }}
          key: toolchain-${{ env.RUST_UP_DEFAULT }}-v${{ env.CACHE_VERSION }}-
      - if: ${{ steps.cache-rustup.outputs.cache-hit != 'true' }}
        run: echo 'Failed to retrieve cache';exit 1
      - id: cache-cargo
        name: Set up cargo cache
        uses: actions/cache/restore@v3
        continue-on-error: false
        with:
          path: ${{ env.CARGO_CACHE_PATH }}
          key: ${{ runner.os }}-cargo-${{ env.CACHE_VERSION }}-${{ hashFiles('**/Cargo.lock') }}
      - run: echo steps.cache-cargo.outputs.cache-hit := ${{ steps.cache-cargo.outputs.cache-hit }}
      - if: ${{ steps.cache-cargo.outputs.cache-hit != 'true' }}
        run: echo 'Failed to retrieve cargo cache';exit 1  
      # The actual job
      - uses: actions/checkout@v4
      - name: Clippy
        run: cargo clippy -- -D warnings

        
  coverage:
    needs: [build]
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always
    steps:
      - run: export RUSTFLAGS="${{ env.RUSTFLAGS }}"
      - id: cache-rustup
        name: Obtain Rust toolchain
        uses: actions/cache/restore@v3
        with:
          path: ${{ env.RUSTUP_CACHE_PATH }}
          key: toolchain-${{ env.RUST_UP_DEFAULT }}-v${{ env.CACHE_VERSION }}-
      - if: ${{ steps.cache-rustup.outputs.cache-hit != 'true' }}
        run: echo 'Failed to retrieve cache';exit 1
      - id: cache-cargo
        name: Set up cargo cache
        uses: actions/cache/restore@v3
        continue-on-error: false
        with:
          path: ${{ env.CARGO_CACHE_PATH }}
          key: ${{ runner.os }}-cargo-${{ env.CACHE_VERSION }}-${{ hashFiles('**/Cargo.lock') }}
      - if: ${{ steps.cache-cargo.outputs.cache-hit != 'true' }}
        run: echo 'Failed to retrieve cargo cache';exit 1  
      - uses: actions/checkout@v4
      - run: cargo test
      - run: grcov . --binary-path target/debug/deps/ -s . -t lcov --ignore-not-existing --ignore '../**' --ignore '/*' -o ./lcov.info
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }} # not required for public repos
          files: lcov.info
      #    fail_ci_if_error: true    


